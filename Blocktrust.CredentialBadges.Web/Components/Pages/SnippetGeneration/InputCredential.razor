@page "/credentialinput"
@rendermode @(new InteractiveServerRenderMode(prerender: false))
@inject NavigationManager NavigationManager
@inject IMediator Mediator
@inject IHttpClientFactory HttpClientFactory
@inject ImageBytesToBase64 ImageBytesToBase64
@using Blocktrust.CredentialBadges.Core.Commands.VerifyOpenBadge
@using Blocktrust.CredentialBadges.Core.Common
@using Blocktrust.CredentialBadges.OpenBadges
@using Blocktrust.CredentialBadges.Core.Commands.Images.ImageDownload
@using Blocktrust.CredentialBadges.Core.Services.Images
@using Blocktrust.CredentialBadges.Web.Commands.VerifiedCredentials.StoreVerifiedCredential
@using Blocktrust.CredentialBadges.Web.Enums
@using MediatR
@using System.Text.RegularExpressions

<PageTitle>Generate Snippet</PageTitle>

<div class="relative min-h-screen w-screen bg-[#F0F1F2] flex items-center justify-center">
   <img src="/images/InputPageRectangle.svg" alt="" class="absolute top-36 left-36 w-16 h-16">
    <img src="/images/InputPageTriangle.svg" alt="" class="absolute top-24 right-24 w-16 h-16">
    <img src="/images/InputPageTriangle.svg" alt="" class="absolute bottom-24 left-24 w-16 h-16">
    <img src="/images/InputPageRectangle.svg" alt="" class="absolute bottom-36 right-36 w-16 h-16">
    
    <div class="flex flex-col bg-[#FAFAFA] border border-gray-200 rounded-lg shadow-md backdrop-filter backdrop-blur-sm p-8 w-full max-w-lg">
        <h1 class="text-2xl font-bold text-[#334155] mb-4">Generate Snippet</h1>
        <p class="text-[#334155] mb-6">
            Input a base 64, jwt or json credential to continue
        </p>

        <label for="credentialInput" class="block text-lg font-medium text-[#334155] mb-2">Input Credential</label>
        <textarea 
            id="credentialInput" 
            rows="4" 
            class="w-full p-2 border border-gray-300 rounded-md text-[#334155] mb-4" 
            placeholder="Enter credential..."
            @bind="credentialInput"
            @onkeydown="HandleKeyDown">
        </textarea>

        <label for="domainInput" class="block text-lg font-medium text-[#334155] mb-2">Domain (Optional)</label>
        <input 
            type="text" 
            id="domainInput" 
            class="w-full p-2 border border-gray-300 rounded-md text-[#334155] mb-4" 
            placeholder="Enter domain (e.g., example.com)"
            @bind="domainInput"
            @bind:event="oninput"
            @onblur="ValidateDomain" />

        @if (!string.IsNullOrEmpty(ErrorMessage))
        {
            <p class="text-red-600 mb-4">@ErrorMessage</p>
        }

        @if (!string.IsNullOrEmpty(Message))
        {
            <p class="text-green-500 mb-4">@Message</p>
        }

        <button
            @onclick="ParseVerifyAndContinue"
            class="bg-[#334155] text-[#F8FAFC] font-medium py-2 px-4 rounded-md hover:bg-[#475569] transition-colors self-center"
            disabled="@IsLoading">
            @if (IsLoading)
            {
                <span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span>
                <span class="sr-only">Loading...</span>
            }
            else
            {
                <span>Continue</span>
            }
        </button>
    </div>
</div>

@code {
    private string credentialInput;
    private string domainInput;
    private string ErrorMessage;
    private string Message;
    private bool IsLoading;

    private void ValidateDomain()
    {
        if (!string.IsNullOrWhiteSpace(domainInput))
        {
            var domainPattern = @"^((?!-)[A-Za-z0-9-]{1,63}(?<!-)\.)+[A-Za-z]{2,6}$";
            if (!Regex.IsMatch(domainInput, domainPattern))
            {
                ErrorMessage = "Please enter a valid domain (e.g., example.com)";
            }
            else
            {
                ErrorMessage = null;
            }
        }
        else
        {
            ErrorMessage = null;
        }
    }

    private async Task HandleKeyDown(KeyboardEventArgs e)
    {
        if (e.Key == "Enter" && !string.IsNullOrEmpty(credentialInput))
        {
            await ParseVerifyAndContinue();
        }
        else if (e.Key == "Escape")
        {
            ErrorMessage = null;
            Message = null;
            credentialInput = null;
            domainInput = null;
            StateHasChanged();
        }
    }

    private async Task ParseVerifyAndContinue()
    {
        IsLoading = true;
        ErrorMessage = null;
        Message = null;

        if (!string.IsNullOrWhiteSpace(domainInput))
        {
            ValidateDomain();
            if (!string.IsNullOrEmpty(ErrorMessage))
            {
                IsLoading = false;
                return;
            }
        }

        try
        {
            var parserResult = CredentialParser.Parse(credentialInput);
            if (parserResult.IsFailed)
            {
                ErrorMessage = "Invalid credential format. Please check your input and try again.";
                return;
            }

            var verifyOpenBadgeResult = await Mediator.Send(new VerifyOpenBadgeRequest(parserResult.Value));
            if (verifyOpenBadgeResult.IsFailed)
            {
                ErrorMessage = "Unable to verify the credential. Please ensure it's valid and try again.";
                return;
            }

            if (!verifyOpenBadgeResult.Value.VerificationIsSuccessfull())
            {
                ErrorMessage = "Verification of the OpenBadge failed. Only verified OpenBadges can be used to generate a snippet.";
                return;
            }

            string image = "";
            if (parserResult.Value is AchievementCredential achievementCredential &&
                achievementCredential.CredentialSubject?.Achievement?.Image?.Id != null)
            {
                image = achievementCredential.CredentialSubject.Achievement.Image.Id.ToString();
            }

            if (!string.IsNullOrEmpty(image) && image.StartsWith("http"))
            {
                var httpClient = HttpClientFactory.CreateClient();
                var handler = new ImageDownloadHandler(httpClient);
                var downloadRequest = new ImageDownloadRequest(image);
                var downloadResult = await handler.HandleAsync(downloadRequest);

                if (downloadResult.IsSuccess)
                {
                    var conversionResult = ImageBytesToBase64.Convert(downloadResult.Value);
                    if (conversionResult.IsSuccess)
                    {
                        image = conversionResult.Value;
                    }
                    else
                    {
                        ErrorMessage = "Failed to process the image. Please try again or use a different image.";
                        return;
                    }
                }
                else
                {
                    ErrorMessage = "Failed to download the image. Please check the image URL and try again.";
                    return;
                }
            }

            var storeVerifiedCredentialRequest = new StoreVerifiedCredentialRequest();

            if (parserResult.Value is AchievementCredential credential)
            {
                storeVerifiedCredentialRequest.Name = credential.CredentialSubject?.Achievement?.Name ?? "Unknown";
                storeVerifiedCredentialRequest.Description = credential.CredentialSubject?.Achievement?.Description ?? "No description";
                storeVerifiedCredentialRequest.Image = image;
                storeVerifiedCredentialRequest.Credential = credentialInput;
                storeVerifiedCredentialRequest.Status = EVerificationStatus.Verified;
                storeVerifiedCredentialRequest.ValidFrom = credential.ValidFrom ?? credential.IssuanceDate ?? DateTime.Now;
                storeVerifiedCredentialRequest.ValidUntil = credential.ValidUntil ?? DateTime.Now.AddYears(1);
                storeVerifiedCredentialRequest.Issuer = credential.Issuer?.Id?.ToString() ?? "Unknown Issuer";
                storeVerifiedCredentialRequest.Domain = !string.IsNullOrWhiteSpace(domainInput) ? domainInput.Trim() : null;
            }
            else
            {
                ErrorMessage = "Invalid credential type. Please provide a valid Achievement Credential.";
                return;
            }

            var storeResult = await Mediator.Send(storeVerifiedCredentialRequest);

            if (!storeResult.IsSuccess)
            {
                ErrorMessage = "Failed to store the credential. Please try again.";
                return;
            }

            Message = "Credential successfully stored!";
            await Task.Delay(1000); 
            NavigationManager.NavigateTo($"/previewbadge/{storeResult.Value.Id}");
        }
        catch (Exception)
        {
            ErrorMessage = "An unexpected error occurred. Please try again later.";
        }
        finally
        {
            IsLoading = false;
        }
    }
}